<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hex Proto - Combat</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0b0c; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    .ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display: flex; gap: 8px; align-items: center;
      background: rgba(0,0,0,0.35); padding: 10px 12px; border-radius: 10px;
      color: rgba(255,255,255,0.9);
      backdrop-filter: blur(6px);
    }
    button {
      border: 0; border-radius: 10px; padding: 8px 10px; cursor: pointer;
      background: rgba(255,255,255,0.12); color: rgba(255,255,255,0.95);
    }
    button:hover { background: rgba(255,255,255,0.18); }
    .hint { font-size: 12px; opacity: 0.8; }
  </style>
</head>
<body>
<div class="ui">
  <button id="btnStart">Start</button>
  <button id="btnReset">Reset</button>
  <div class="hint">Drag & drop avant Start. Aggro = plus proche.</div>
</div>
<canvas id="c"></canvas>

<script>
const GRID_W = 10, GRID_H = 8;
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let HEX_SIZE = 24; // auto-fit after resize

function hexWidth() { return Math.sqrt(3) * HEX_SIZE; }
function hexHeight(){ return 2 * HEX_SIZE; }
function hexVStep(){ return 1.5 * HEX_SIZE; }

function autoFitHexSize(){
  // Fit the grid into canvas with some padding.
  // Grid width approx: hexWidth * (W + 0.5) + hexWidth (margin-ish)
  // Grid height approx: hexVStep*(H-1) + hexHeight + hexHeight (margin-ish)
  const pad = 20 * devicePixelRatio;

  // Solve for size from width constraint
  // width ≈ sqrt(3)*S*(W+0.5) + 2S   (rough padding for corners)
  // => S ≈ (availW) / (sqrt(3)*(W+0.5) + 2)
  const denomW = (Math.sqrt(3) * (GRID_W + 0.5) + 2);
  const sFromW = (canvas.width - 2*pad) / denomW;

  // height ≈ 1.5S*(H-1) + 2S + 2S  (corners + margin)
  // => S ≈ (availH) / (1.5*(H-1) + 4)
  const denomH = (1.5 * (GRID_H - 1) + 4);
  const sFromH = (canvas.height - 2*pad) / denomH;

  HEX_SIZE = Math.max(10 * devicePixelRatio, Math.floor(Math.min(sFromW, sFromH)));
}

function resize(){
  canvas.width = Math.floor(window.innerWidth * devicePixelRatio);
  canvas.height = Math.floor(window.innerHeight * devicePixelRatio);
  autoFitHexSize();
}
window.addEventListener("resize", resize);
resize();

// ----- Hex (pointy-top, odd-r offset) -----
function hexToPixel(q, r){
  const x = hexWidth() * (q + 0.5 * (r & 1));
  const y = hexVStep() * r;
  return { x, y };
}
function hexCorner(cx, cy, i){
  const angle = (Math.PI / 180) * (60 * i - 30);
  return { x: cx + HEX_SIZE * Math.cos(angle), y: cy + HEX_SIZE * Math.sin(angle) };
}
function drawHexOutline(cx, cy){
  ctx.beginPath();
  const p0 = hexCorner(cx, cy, 0);
  ctx.moveTo(p0.x, p0.y);
  for(let i=1;i<6;i++){
    const p = hexCorner(cx, cy, i);
    ctx.lineTo(p.x, p.y);
  }
  ctx.closePath();
  ctx.stroke();
}

function gridBoundsPx(){
  const width = hexWidth() * (GRID_W + 0.5);
  const height = hexVStep() * (GRID_H - 1) + hexHeight();
  return { width, height };
}
function computeOrigin(){
  const b = gridBoundsPx();
  const ox = (canvas.width - b.width)/2 + HEX_SIZE;
  const oy = (canvas.height - b.height)/2 + HEX_SIZE;
  return { ox, oy };
}
function worldToLocal(px, py){
  const {ox, oy} = computeOrigin();
  return { x: px - ox, y: py - oy };
}
function localToWorld(x, y){
  const {ox, oy} = computeOrigin();
  return { x: x + ox, y: y + oy };
}

// pixel -> hex: nearest center among nearby candidates
function pixelToHex(localX, localY){
  const rApprox = localY / hexVStep();
  const r0 = Math.round(rApprox);

  let best = null;
  for(let dr=-1; dr<=1; dr++){
    const r = r0 + dr;
    if(r < 0 || r >= GRID_H) continue;
    const qApprox = (localX / hexWidth()) - 0.5 * (r & 1);
    const q0 = Math.round(qApprox);

    for(let dq=-1; dq<=1; dq++){
      const q = q0 + dq;
      if(q < 0 || q >= GRID_W) continue;
      const {x,y} = hexToPixel(q, r);
      const dx = localX - x, dy = localY - y;
      const d2 = dx*dx + dy*dy;
      if(!best || d2 < best.d2) best = { q, r, d2 };
    }
  }
  return best ? { q: best.q, r: best.r } : null;
}

// ----- Distance via axial conversion -----
function offsetToAxial(q, r){
  const aq = q - ((r - (r & 1)) / 2);
  const ar = r;
  return { aq, ar };
}
function axialToOffset(aq, ar){
  const r = ar;
  const q = aq + ((r - (r & 1)) / 2);
  return { q, r };
}
function hexDist(q1,r1,q2,r2){
  const a = offsetToAxial(q1,r1);
  const b = offsetToAxial(q2,r2);
  const dq = b.aq - a.aq;
  const dr = b.ar - a.ar;
  return (Math.abs(dq) + Math.abs(dr) + Math.abs(dq+dr)) / 2;
}
const DIRS_AXIAL = [
  {dq:+1, dr:0}, {dq:-1, dr:0}, {dq:0, dr:+1}, {dq:0, dr:-1}, {dq:+1, dr:-1}, {dq:-1, dr:+1}
];
function neighbors(q, r){
  const a = offsetToAxial(q,r);
  const out = [];
  for(const d of DIRS_AXIAL){
    const no = axialToOffset(a.aq + d.dq, a.ar + d.dr);
    if(no.q>=0 && no.q<GRID_W && no.r>=0 && no.r<GRID_H) out.push(no);
  }
  return out;
}

// ----- Units / combat -----
const COLORS = {
  red:   "#e74c3c",
  green: "#2ecc71",
  blue:  "#3498db",
  yellow:"#f1c40f",
  gray:  "#b0b3b8"
};

function makeUnit({id, team, q, r, color, role}){
  const u = { id, team, q, r, color, role, hp:100, maxHp:100, alive:true,
    tauntedBy:null, tauntT:0, stunnedT:0, atkCd:0, skillCd:0
  };
  if(role==="warrior"){ u.maxHp=u.hp=160; u.atk=18; u.range=1; u.atkCdBase=0.9; u.skillCdBase=6.0; }
  if(role==="archer") { u.maxHp=u.hp=95;  u.atk=16; u.range=3; u.atkCdBase=1.0; u.skillCdBase=5.0; }
  if(role==="mage")   { u.maxHp=u.hp=90;  u.atk=14; u.range=3; u.atkCdBase=1.1; u.skillCdBase=6.0; }
  if(role==="diver")  { u.maxHp=u.hp=120; u.atk=17; u.range=1; u.atkCdBase=1.0; u.skillCdBase=5.5; }
  if(role==="grunt")  { u.maxHp=u.hp=100; u.atk=12; u.range=1; u.atkCdBase=1.1; u.skillCdBase=999; }
  return u;
}

let units = [];
let running = false;
let hoverHex = null;

function resetGame(){
  running = false;
  units = [
    makeUnit({id:1, team:"P", q:1, r:2, color:COLORS.red, role:"warrior"}),
    makeUnit({id:2, team:"P", q:2, r:3, color:COLORS.green, role:"archer"}),
    makeUnit({id:3, team:"P", q:1, r:4, color:COLORS.blue, role:"mage"}),
    makeUnit({id:4, team:"P", q:2, r:5, color:COLORS.yellow, role:"diver"}),

    makeUnit({id:101, team:"E", q:8, r:2, color:COLORS.gray, role:"grunt"}),
    makeUnit({id:102, team:"E", q:8, r:3, color:COLORS.gray, role:"grunt"}),
    makeUnit({id:103, team:"E", q:8, r:4, color:COLORS.gray, role:"grunt"}),
    makeUnit({id:104, team:"E", q:8, r:5, color:COLORS.gray, role:"grunt"}),
    makeUnit({id:105, team:"E", q:7, r:3, color:COLORS.gray, role:"grunt"}),
  ];
}
resetGame();

function unitAt(q, r){ return units.find(u => u.alive && u.q===q && u.r===r) || null; }
function living(team){ return units.filter(u => u.alive && u.team===team); }
function enemyTeam(team){ return team==="P" ? "E" : "P"; }

function nearestEnemy(u){
  const enemies = living(enemyTeam(u.team));
  if(enemies.length===0) return null;
  if(u.tauntT > 0 && u.tauntedBy !== null){
    const t = units.find(x => x.id===u.tauntedBy && x.alive);
    if(t) return t;
  }
  let best=null;
  for(const e of enemies){
    const d = hexDist(u.q,u.r,e.q,e.r);
    if(!best || d<best.d) best={e,d};
  }
  return best.e;
}

function stepToward(u, target){
  const nbs = neighbors(u.q,u.r).filter(h => !unitAt(h.q,h.r));
  let best=null;
  for(const h of nbs){
    const d = hexDist(h.q,h.r,target.q,target.r);
    if(!best || d<best.d) best={h,d};
  }
  return best ? best.h : null;
}
function stepAway(u){
  const enemies = living(enemyTeam(u.team));
  const nbs = neighbors(u.q,u.r).filter(h => !unitAt(h.q,h.r));
  let best=null;
  for(const h of nbs){
    let minD=Infinity;
    for(const e of enemies){
      const d = hexDist(h.q,h.r,e.q,e.r);
      if(d<minD) minD=d;
    }
    if(!best || minD>best.minD) best={h,minD};
  }
  return best ? best.h : null;
}

function applyDamage(src, tgt, amount){
  tgt.hp -= amount;
  if(tgt.hp <= 0){
    tgt.hp=0; tgt.alive=false;
    for(const u of units){
      if(u.tauntedBy === tgt.id){ u.tauntedBy=null; u.tauntT=0; }
    }
  }
}

// abilities
function warriorTaunt(u){
  const enemies = living(enemyTeam(u.team));
  for(const e of enemies){
    if(hexDist(u.q,u.r,e.q,e.r) <= 2){
      e.tauntedBy = u.id;
      e.tauntT = Math.max(e.tauntT, 2.5);
    }
  }
}
function archerJump(u){
  const enemies = living(enemyTeam(u.team));
  let adjacent=false;
  for(const e of enemies){ if(hexDist(u.q,u.r,e.q,e.r) <= 1){ adjacent=true; break; } }
  if(!adjacent) return false;
  const h = stepAway(u);
  if(!h) return false;
  u.q=h.q; u.r=h.r;
  return true;
}
function mageStun(u, target){
  if(hexDist(u.q,u.r,target.q,target.r) > u.range) return false;
  target.stunnedT = Math.max(target.stunnedT, 1.6);
  return true;
}
function diverDash(u, target){
  if(hexDist(u.q,u.r,target.q,target.r) <= 1) return false;
  let steps=2;
  while(steps-- > 0){
    const h = stepToward(u, target);
    if(!h) break;
    u.q=h.q; u.r=h.r;
    if(hexDist(u.q,u.r,target.q,target.r) <= 1) break;
  }
  return true;
}

// tick
const TICK = 0.2;
let acc = 0;
let lastTs = performance.now();

function aiTick(){
  if(living("P").length===0 || living("E").length===0){ running=false; return; }

  for(const u of units){
    if(!u.alive) continue;

    u.tauntT = Math.max(0, u.tauntT - TICK);
    if(u.tauntT === 0){ u.tauntedBy = null; }
    u.stunnedT = Math.max(0, u.stunnedT - TICK);

    u.atkCd = Math.max(0, u.atkCd - TICK);
    u.skillCd = Math.max(0, u.skillCd - TICK);

    if(u.stunnedT > 0) continue;

    const target = nearestEnemy(u);
    if(!target) continue;

    const dist = hexDist(u.q,u.r,target.q,target.r);

    if(u.skillCd <= 0){
      let used=false;
      if(u.role==="warrior"){ if(dist<=2){ warriorTaunt(u); used=true; } }
      else if(u.role==="archer"){ used = archerJump(u); }
      else if(u.role==="mage"){ used = mageStun(u, target); }
      else if(u.role==="diver"){ used = diverDash(u, target); }
      if(used) u.skillCd = u.skillCdBase;
    }

    const t2 = nearestEnemy(u) || target;
    const d2 = t2 ? hexDist(u.q,u.r,t2.q,t2.r) : dist;

    if(u.atkCd<=0 && t2 && t2.alive && d2<=u.range){
      applyDamage(u, t2, u.atk);
      u.atkCd = u.atkCdBase;
      continue;
    }
    if(t2 && d2>u.range){
      const h = stepToward(u, t2);
      if(h){ u.q=h.q; u.r=h.r; }
    }
  }
}

// render
function drawUnit(u, isDragging=false, worldX=null, worldY=null){
  const radius = HEX_SIZE * 0.45;

  let cx, cy;
  if(isDragging){
    cx = worldX; cy = worldY;
  } else {
    const pLocal = hexToPixel(u.q, u.r);
    const pWorld = localToWorld(pLocal.x, pLocal.y);
    cx = pWorld.x; cy = pWorld.y;
  }

  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI*2);
  ctx.fillStyle = u.color;
  ctx.fill();

  ctx.lineWidth = 2 * devicePixelRatio;
  ctx.strokeStyle = "rgba(0,0,0,0.45)";
  ctx.stroke();

  if(u.stunnedT > 0){
    ctx.beginPath();
    ctx.arc(cx, cy, radius*1.08, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 3 * devicePixelRatio;
    ctx.stroke();
  } else if(u.tauntT > 0 && u.team==="E"){
    ctx.beginPath();
    ctx.arc(cx, cy, radius*1.08, 0, Math.PI*2);
    ctx.strokeStyle = "rgba(231,76,60,0.70)";
    ctx.lineWidth = 3 * devicePixelRatio;
    ctx.stroke();
  }

  // HP bar
  const barW = radius * 2.0;
  const barH = 6 * devicePixelRatio;
  const x0 = cx - barW/2;
  const y0 = cy + radius + 8 * devicePixelRatio;

  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(x0, y0, barW, barH);

  const t = Math.max(0, Math.min(1, u.hp / u.maxHp));
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  ctx.fillRect(x0, y0, barW * t, barH);
}

let dragging = null;
let pointerWorld = {x:0,y:0};

function getPointerWorld(e){
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * devicePixelRatio;
  const y = (e.clientY - rect.top) * devicePixelRatio;
  return { x, y };
}
function unitHitTest(worldX, worldY){
  const radius = HEX_SIZE * 0.55;
  for(let i=units.length-1; i>=0; i--){
    const u = units[i];
    if(!u.alive || u.team!=="P") continue;
    const cLocal = hexToPixel(u.q, u.r);
    const cWorld = localToWorld(cLocal.x, cLocal.y);
    const dx = worldX - cWorld.x, dy = worldY - cWorld.y;
    if(dx*dx + dy*dy <= radius*radius) return u;
  }
  return null;
}

canvas.addEventListener("pointerdown", (e)=>{
  canvas.setPointerCapture(e.pointerId);
  const p = getPointerWorld(e);
  pointerWorld = p;
  const local = worldToLocal(p.x, p.y);
  hoverHex = pixelToHex(local.x, local.y);

  if(running) return;
  const u = unitHitTest(p.x, p.y);
  if(!u) return;
  dragging = { unit:u, start_q:u.q, start_r:u.r, pointerId:e.pointerId };
});
canvas.addEventListener("pointermove", (e)=>{
  const p = getPointerWorld(e);
  pointerWorld = p;
  const local = worldToLocal(p.x, p.y);
  hoverHex = pixelToHex(local.x, local.y);
});
canvas.addEventListener("pointerup", (e)=>{
  if(!dragging || dragging.pointerId!==e.pointerId) return;
  if(running){ dragging=null; return; }

  const p = getPointerWorld(e);
  const local = worldToLocal(p.x, p.y);
  const h = pixelToHex(local.x, local.y);

  if(h && !unitAt(h.q,h.r)){
    dragging.unit.q=h.q; dragging.unit.r=h.r;
  } else {
    dragging.unit.q=dragging.start_q; dragging.unit.r=dragging.start_r;
  }
  dragging=null;
});
canvas.addEventListener("pointercancel", (e)=>{
  if(!dragging || dragging.pointerId!==e.pointerId) return;
  dragging.unit.q=dragging.start_q; dragging.unit.r=dragging.start_r;
  dragging=null;
});

document.getElementById("btnStart").addEventListener("click", ()=>{
  if(running) return;
  for(const u of units){
    u.tauntedBy=null; u.tauntT=0; u.stunnedT=0;
    u.atkCd=0; u.skillCd=0;
    u.alive = (u.hp > 0);
  }
  running=true;
  acc=0;
  lastTs=performance.now();
});
document.getElementById("btnReset").addEventListener("click", ()=>{
  resetGame();
});

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#0b0b0c";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const {ox, oy} = computeOrigin();
  ctx.save();
  ctx.translate(ox, oy);

  ctx.lineWidth = 2 * devicePixelRatio;
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  for(let r=0;r<GRID_H;r++){
    for(let q=0;q<GRID_W;q++){
      const {x,y} = hexToPixel(q, r);
      drawHexOutline(x, y);
    }
  }

  if(!running && hoverHex){
    const {x,y} = hexToPixel(hoverHex.q, hoverHex.r);
    ctx.beginPath();
    const p0 = hexCorner(x, y, 0);
    ctx.moveTo(p0.x, p0.y);
    for(let i=1;i<6;i++){
      const p = hexCorner(x, y, i);
      ctx.lineTo(p.x, p.y);
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.fill();
  }

  ctx.restore();

  for(const u of units){
    if(!u.alive) continue;
    if(dragging && dragging.unit.id===u.id) continue;
    drawUnit(u);
  }
  if(dragging){
    drawUnit(dragging.unit, true, pointerWorld.x, pointerWorld.y);
  }

  const now = performance.now();
  const dt = (now - lastTs)/1000;
  lastTs = now;

  if(running){
    acc += dt;
    while(acc >= TICK){
      aiTick();
      acc -= TICK;
    }
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
